package acis.dbis.rwth.mobsos.monitor.log;

import java.net.UnknownHostException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Hashtable;

import acis.dbis.rwth.mobsos.monitor.Monitor;
import acis.dbis.rwth.mobsos.monitor.notify.NotificationManager;

/**
 * This class defines an individual worker thread, repeatedly consuming single {@link LogEntryPackage} instances from the queue managed 
 * in {@link LogEntryPackageManager} in a synchronized manner and then writing them to the MobSOS monitoring database, using their 
 * {@link LogEntryPackage#write()} method.
 * 
 * Any instance of this class is equipped with a set of {@link PreparedStatement}, one for each type of {@link LogEntry}
 * in a {@link LogEntryPackage}. Since all {@link PreparedStatement}s are bound to the {@link Connection} they were created
 * with, any instance of this class will only consume {@link LogEntryPackage} instances from the queue, if a check on the liveness of
 * the corresponding connection is successful. If this test fails, the particular instance is disposed.
 * 
 * If writing a {@link LogEntryPackage} fails for some reason, this class realizes a notification mechanism, reporting the
 * occurred failure and related information via email to all recipients defined in the configuration file of the LAS HTTP Connector.
 * 
 * @author Dominik Renzel
 * @version $Revision: 1.1.2.8 $, $Date: 2014/02/05 12:59:20 $
 */
public class LogEntryPackageWorker extends Thread {

	private final LogEntryPackageManager manager;
	private Hashtable<Integer,PreparedStatement> preparedStatementTable;
	private static int instance = 0;


	public LogEntryPackageWorker(LogEntryPackageManager m) throws SQLException {
		this.setName("LEPW-"+(instance++));
		this.manager = m;
		initPreparedStatements();
		Monitor.log.info("Log Entry Package Worker " + getName() + " ready...");
	}

	/**
	 * Initializes all prepared statements for writing different kinds of log entries to the log database.
	 * These prepared statements are then used by {@link LogDatabaseWriteWorker} instances to write 
	 * respective log entries to the right log database tables.
	 * 
	 * @throws SQLException 
	 */
	private void initPreparedStatements() throws SQLException{

		// initialize hash table for prepared statements
		preparedStatementTable = new Hashtable<Integer,PreparedStatement>();

		/*
		// prepared statement for session log entries. New session identifiers are generated by LAS,
		// and not by the database. Thus, these statements can be executed with an update.
		String session_sql = "INSERT INTO MOBSOS.SESSION (SID,UID,STIME,ETIME,TIMEOUT,PLATFORM,CONFIG,PROFILE,USERAGENT,APPCODE) VALUES (?,?,?,?,?,?,?,?,?,?)";
		PreparedStatement session_ps = manager.getConnection().prepareStatement(session_sql);
		preparedStatementTable.put(LogEntry.SESSION_TYPE, session_ps);

		// prepared statement for updating end time of session log entries. In particular relevant for
		// touch session, and invocation requests, where timeout is renewed, and close session requests,
		// where session end time is finally set.
		String session_up_sql = "UPDATE MOBSOS.SESSION SET ETIME = ? WHERE (SID = ?)";
		PreparedStatement session_up_ps = manager.getConnection().prepareStatement(session_up_sql);
		preparedStatementTable.put(LogEntry.SESSION_UPDATE_TYPE, session_up_ps);

		// prepared statement for central request log entries, generating new identifiers.
		// these statements should be executed as queries to get hands on the generated identifier.
		// Furthermore, they should be executed after the respective session log entry was created.
		String request_sql = "SELECT ID FROM NEW TABLE(INSERT INTO MOBSOS.REQUEST(REMOTE_ADDR,SID,REQ_TYPE,STIME,ETIME,REQ_SIZE,RES_SIZE, RES_STATUS) VALUES (?,?,?,?,?,?,?,?))";
		PreparedStatement request_ps = manager.getConnection().prepareStatement(request_sql);
		preparedStatementTable.put(LogEntry.REQUEST_TYPE, request_ps);

		// prepared statement for service method invocations. The request id should be the one generated
		// from inserting the respective corresponding request log entry before.
		String invocation_sql = "INSERT INTO MOBSOS.INVOCATION(REQID,SCODE,MNAME,STIME,ETIME,PARAM_CNT,RES_CNT) VALUES (?,?,?,?,?,?,?)";
		PreparedStatement invocation_ps = manager.getConnection().prepareStatement(invocation_sql);
		preparedStatementTable.put(LogEntry.INVOCATION_TYPE, invocation_ps);

		// prepared statement for context log entries. The identifier should be the one generated
		// from inserting the respective corresponding request log entry before.
		String context_sql = "INSERT INTO MOBSOS.MCONTEXT(REQID,CID,LATITUDE,LONGITUDE,ALTITUDE,GSPEED,MEDIA_URI) VALUES (?,?,?,?,?,?,?)";
		PreparedStatement context_ps = manager.getConnection().prepareStatement(context_sql);
		preparedStatementTable.put(LogEntry.CONTEXT_TYPE, context_ps);

		// prepared statement for exception log entries. The request id should be the one generated
		// from inserting the respective corresponding request log entry before.
		String exception_sql = "INSERT INTO MOBSOS.EXCPTION(REQID,CLASS,MSG) VALUES (?,?,?)";
		PreparedStatement exception_ps = manager.getConnection().prepareStatement(exception_sql);
		preparedStatementTable.put(LogEntry.EXCEPTION_TYPE, exception_ps);
		
		// prepared statement for header log entries. The request id should be the one generated
		// from inserting the respective corresponding request log entry before.
		String headers_sql = "INSERT INTO MOBSOS.HEADERS(REQID,HEADERS) VALUES (?,?)";
		PreparedStatement headers_ps = manager.getConnection().prepareStatement(headers_sql);
		preparedStatementTable.put(LogEntry.HEADERS_TYPE, headers_ps);
		*/
	}

	public PreparedStatement getPreparedStatement(Integer type){
		if(preparedStatementTable == null || !preparedStatementTable.keySet().contains(type)){
			throw new IllegalArgumentException("No prepared statement available for type " + type);
		}
		return this.preparedStatementTable.get(type);
	}

	@Override
	public void run() {
		try {
			// only do something when connection is active. As soon as the current connection becomes inactive, the current worker
			// becomes useless, since all of his prepared statements are also closed and need to be renewed with a new connection.
			// In this case, it can be disposed.
			while (!manager.getConnection().isClosed()) {
				LogEntryPackage l = null;
				

				synchronized ( manager.getQueue() ) {

					while (manager.getConnection().isClosed() || manager.getQueue().isEmpty()){
						manager.getQueue().wait();
					}

					// Get the next work item off of the queue 
					l = manager.getQueue().remove();

					// if log entry package describes a complete and successful create session request,
					// write it within the synchronized block before allowing LogEntryPackageWorker instances
					// can process subsequent log entry packages (see comment below for explanation)
					/*
					if(l != null && l.getSessionLogEntry().isComplete()){
						l.setWorker(this);
						writeLogEntryPackage(l);
					}*/
				}

				// At this point, we have to treat log entry packages describing a create session request differently.
				// Here is the problem, why we have to do this:
				// Let l1 and l2 be two log entry packages with l1 describing a create session operation and 
				// l2 a subsequent method invocation operation within the new session. In the case that l1 
				// and l2 are taken out of the queue and l1 is not written before l2, l2's writing transaction 
				// will roll back, because the database will throw an exception because of a violated foreign 
				// key dependency, i.e. an entry in the session table to which l2 refers does not exist yet, 
				// because l1 was not yet written.
				// To avoid this case, we will write log entry packages with complete session log entries *within* the
				// synchronized block, so log entry packages describing subsequent requests will not have to roll back.

				// Let work item know which worker is responsible, then write log entry
				/*
				if(l != null && !l.getSessionLogEntry().isComplete()){
					l.setWorker(this);
					writeLogEntryPackage(l);
				}*/
			}
			Monitor.log.debug("Worker " + getName() + " going down due to lost database connection.");
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		} catch (SQLException e) {
			Thread.currentThread().interrupt();
		}
	}


	private void writeLogEntryPackage(LogEntryPackage l){
		try{
			l.write();
		} 
		catch (Exception e) {

			// if any exception occurs while writing a complete log entry package, roll back
			// complete transaction and send notification via mail.
			boolean rbComplete = false;
			try {
				if(this.manager.getConnection() != null && !this.manager.getConnection().isClosed()){
					Monitor.log.error("Transaction for log entry package " + this.getId() + " rolled back!",e);
					this.manager.getConnection().rollback();
					rbComplete = true;
				}
			} catch (Exception e1) {
				Monitor.log.error("Unknown error!",e1);
			}

			// send notification about failed writing of log entry package
			String message = "Worker " + this.getName() + " failed to write package " + l.getId() + "."; 
			if(rbComplete){
				message += "(transaction rolled back)";
			} else {
				message += "(transaction rollback failed!)";
			}
			System.err.println(message);
			e.printStackTrace();

			// when sending error notifications, let the notified people know from which 
			// LAS/MobSOS installation the message came...
			java.net.InetAddress localMachine;
			String hostName = "localhost";
			String hostAddress = "127.0.0.1";
			try {
				localMachine = java.net.InetAddress.getLocalHost();
				hostName = localMachine.getCanonicalHostName();
				hostAddress = localMachine.getHostAddress();
			} catch (UnknownHostException e1) {
				e1.printStackTrace();
			}

			message = "MobSOS Monitor on " + hostName + " (" + hostAddress + ") reports operation failure: " + message;
			// attach deserialization of complete log entry package to message for easier debugging
			message += l.toString();
			
			//System.out.println("Mail to be sent (reactivate notification manager!!): "+message);
			NotificationManager.getInstance().notifyFailure(message, e);

		} finally {
			l = null;
		}
	}
}